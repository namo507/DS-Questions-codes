---
title: "Product of Array Except Self"
subtitle: "LeetCode #238 | Medium | Arrays & Prefix/Suffix"
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    code-block-bg: "#f5f5f5"
---

# ğŸ‹ï¸ Problem Statement

**LeetCode #238 - Product of Array Except Self**

Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the **product of all the elements** of `nums` **except** `nums[i]`.

The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

You must write an algorithm that runs in **O(n)** time and **without using the division operation**.

## Examples

| Example | Input | Output | Explanation |
|:--------|:------|:-------|:------------|
| 1 | `[1,2,3,4]` | `[24,12,8,6]` | 24=2Ã—3Ã—4, 12=1Ã—3Ã—4, 8=1Ã—2Ã—4, 6=1Ã—2Ã—3 |
| 2 | `[-1,1,0,-3,3]` | `[0,0,9,0,0]` | Only index 2 has non-zero product |

## Constraints

- $2 \leq \text{nums.length} \leq 10^5$
- $-30 \leq \text{nums}[i] \leq 30$
- Product of any prefix/suffix fits in 32-bit integer

## Follow-up

Can you solve it in O(1) extra space complexity? (The output array **does not** count as extra space.)

## Companies That Ask This

| Company | Frequency |
|:--------|:----------|
| Amazon | â­â­â­â­â­ |
| Apple | â­â­â­â­â­ |
| Meta | â­â­â­â­â­ |
| Microsoft | â­â­â­â­ |
| Google | â­â­â­â­ |

---

# ğŸ‹ï¸ The Gym Metaphor: Calculating Team Strength Without One Member

## Understanding the Problem Through Fitness

Imagine you're a **team coach** calculating the **combined strength** of your gym team for relay competitions.

**Team Members and Their Strength Multipliers:**
```
Position:  0    1    2    3
Member:  [1x,  2x,  3x,  4x]   (strength multipliers)
```

**The Challenge**: For each member, calculate the **team's combined strength if that member is RESTING**.

```
If Member 0 rests: Team strength = 2 Ã— 3 Ã— 4 = 24
If Member 1 rests: Team strength = 1 Ã— 3 Ã— 4 = 12
If Member 2 rests: Team strength = 1 Ã— 2 Ã— 4 = 8
If Member 3 rests: Team strength = 1 Ã— 2 Ã— 3 = 6
```

**Answer**: `[24, 12, 8, 6]`

---

## The Naive Approach: Calculate Each Team Separately

For each resting member, multiply everyone else:

```
Member 0 rests: multiply positions 1, 2, 3
Member 1 rests: multiply positions 0, 2, 3
Member 2 rests: multiply positions 0, 1, 3
Member 3 rests: multiply positions 0, 1, 2
```

**Problem**: For each of n members, we do n-1 multiplications â†’ **O(nÂ²)** â€” too slow!

---

## The Clever Division Approach (NOT ALLOWED!)

```
Total product = 1 Ã— 2 Ã— 3 Ã— 4 = 24
For Member 0: 24 / 1 = 24
For Member 1: 24 / 2 = 12
...
```

**Problem**: Division is prohibited, and zeros cause divide-by-zero errors!

---

## The Smart Approach: Prefix and Suffix Products

Think of it like **team formation drills**:

> **"The strength WITHOUT member i = (everyone BEFORE i) Ã— (everyone AFTER i)"**

### Gym Visualization

```
Position:     0    1    2    3
Strength:    [1,   2,   3,   4]

For position 2 (strength=3):
- Members BEFORE (prefix): 1 Ã— 2 = 2
- Members AFTER (suffix): 4
- Team without position 2: 2 Ã— 4 = 8 âœ“
```

### Building Prefix Products (Left Side)

Like calculating "cumulative team strength from the LEFT":

```
Position:     0    1    2    3
Original:    [1,   2,   3,   4]

Prefix products (everyone to my LEFT):
prefix[0] = 1 (no one to the left)
prefix[1] = 1 (only position 0)
prefix[2] = 1 Ã— 2 = 2 (positions 0, 1)
prefix[3] = 1 Ã— 2 Ã— 3 = 6 (positions 0, 1, 2)

Prefix:      [1,   1,   2,   6]
```

### Building Suffix Products (Right Side)

Like calculating "cumulative team strength from the RIGHT":

```
Position:     0    1    2    3
Original:    [1,   2,   3,   4]

Suffix products (everyone to my RIGHT):
suffix[3] = 1 (no one to the right)
suffix[2] = 4 (only position 3)
suffix[1] = 4 Ã— 3 = 12 (positions 2, 3)
suffix[0] = 4 Ã— 3 Ã— 2 = 24 (positions 1, 2, 3)

Suffix:      [24,  12,  4,   1]
```

### Final Answer: Prefix Ã— Suffix

```
Position:     0    1    2    3
Prefix:      [1,   1,   2,   6]
Suffix:      [24,  12,  4,   1]
Answer:      [24,  12,  8,   6]  (prefix Ã— suffix)
```

| Position | Prefix (Left) | Suffix (Right) | Answer |
|:---------|:--------------|:---------------|:-------|
| 0 | 1 | 24 | 1 Ã— 24 = **24** |
| 1 | 1 | 12 | 1 Ã— 12 = **12** |
| 2 | 2 | 4 | 2 Ã— 4 = **8** |
| 3 | 6 | 1 | 6 Ã— 1 = **6** |

---

# ğŸ’» Python Solution

```{python}
def product_except_self(nums: list[int]) -> list[int]:
    """
    Calculate product of all elements except self.
    
    The Team Strength Strategy:
    - Calculate prefix products (strength of everyone to the LEFT)
    - Calculate suffix products (strength of everyone to the RIGHT)
    - Answer = prefix Ã— suffix
    
    Time Complexity: O(n) - Three passes
    Space Complexity: O(n) - Two extra arrays
    """
    n = len(nums)
    
    # Prefix products: prefix[i] = product of nums[0..i-1]
    prefix = [1] * n
    for i in range(1, n):
        prefix[i] = prefix[i-1] * nums[i-1]
    
    # Suffix products: suffix[i] = product of nums[i+1..n-1]
    suffix = [1] * n
    for i in range(n-2, -1, -1):
        suffix[i] = suffix[i+1] * nums[i+1]
    
    # Result: prefix Ã— suffix
    result = [prefix[i] * suffix[i] for i in range(n)]
    
    return result


# Test cases
print("Example 1:", product_except_self([1, 2, 3, 4]))      # [24, 12, 8, 6]
print("Example 2:", product_except_self([-1, 1, 0, -3, 3])) # [0, 0, 9, 0, 0]


# Optimized: O(1) extra space (using output array)
def product_except_self_optimized(nums: list[int]) -> list[int]:
    """
    Space-optimized version using output array for prefix,
    then applying suffix in a single pass.
    
    Space Complexity: O(1) extra (output doesn't count)
    """
    n = len(nums)
    result = [1] * n
    
    # First pass: Calculate prefix products in result array
    prefix = 1
    for i in range(n):
        result[i] = prefix
        prefix *= nums[i]
    
    # Second pass: Multiply by suffix products
    suffix = 1
    for i in range(n-1, -1, -1):
        result[i] *= suffix
        suffix *= nums[i]
    
    return result


print("\nOptimized version:")
print("Example 1:", product_except_self_optimized([1, 2, 3, 4]))  # [24, 12, 8, 6]
```

---

# ğŸ“Š R Solution

```{r}
product_except_self <- function(nums) {
  #' Calculate product of all elements except self.
  #' 
  #' The Team Strength Strategy:
  #' - Calculate prefix products (strength of everyone to the LEFT)
  #' - Calculate suffix products (strength of everyone to the RIGHT)
  #' - Answer = prefix Ã— suffix
  #' 
  #' Time Complexity: O(n) - Three passes
  #' Space Complexity: O(n) - Two extra arrays
  
  n <- length(nums)
  
  # Prefix products: prefix[i] = product of nums[1..i-1]
  prefix <- rep(1, n)
  for (i in 2:n) {
    prefix[i] <- prefix[i-1] * nums[i-1]
  }
  
  # Suffix products: suffix[i] = product of nums[i+1..n]
  suffix <- rep(1, n)
  for (i in (n-1):1) {
    suffix[i] <- suffix[i+1] * nums[i+1]
  }
  
  # Result: prefix Ã— suffix
  result <- prefix * suffix
  
  return(result)
}


# Test cases
cat("Example 1:", product_except_self(c(1, 2, 3, 4)), "\n")      # 24 12 8 6
cat("Example 2:", product_except_self(c(-1, 1, 0, -3, 3)), "\n") # 0 0 9 0 0


# Optimized: O(1) extra space
product_except_self_optimized <- function(nums) {
  #' Space-optimized version using output array for prefix,
  #' then applying suffix in a single pass.
  #' 
  #' Space Complexity: O(1) extra (output doesn't count)
  
  n <- length(nums)
  result <- rep(1, n)
  
  # First pass: Calculate prefix products
  prefix <- 1
  for (i in 1:n) {
    result[i] <- prefix
    prefix <- prefix * nums[i]
  }
  
  # Second pass: Multiply by suffix products
  suffix <- 1
  for (i in n:1) {
    result[i] <- result[i] * suffix
    suffix <- suffix * nums[i]
  }
  
  return(result)
}


cat("\nOptimized version:\n")
cat("Example 1:", product_except_self_optimized(c(1, 2, 3, 4)), "\n")  # 24 12 8 6


# Vectorized approach (for understanding, still O(n) passes)
product_except_self_vectorized <- function(nums) {
  #' Using R's vectorized operations
  
  n <- length(nums)
  
  # Cumulative product from left (shift right by 1)
  prefix <- c(1, cumprod(nums[-n]))
  
  # Cumulative product from right (shift left by 1)
  suffix <- c(rev(cumprod(rev(nums[-1]))), 1)
  
  return(prefix * suffix)
}


cat("\nVectorized version:\n")
cat("Example 1:", product_except_self_vectorized(c(1, 2, 3, 4)), "\n")
```

---

# ğŸ” Solution Breakdown: The Full Gym Session Analysis

## Algorithm Walkthrough with Detailed Table

**Input**: `nums = [1, 2, 3, 4]`

### Step 1: Build Prefix Products

| i | nums[i] | Calculation | prefix[i] | Meaning |
|:--|:--------|:------------|:----------|:--------|
| 0 | 1 | (no elements to left) | 1 | Empty product |
| 1 | 2 | nums[0] | 1 | Product of [1] |
| 2 | 3 | nums[0] Ã— nums[1] | 2 | Product of [1,2] |
| 3 | 4 | nums[0] Ã— nums[1] Ã— nums[2] | 6 | Product of [1,2,3] |

**Prefix Array**: `[1, 1, 2, 6]`

### Step 2: Build Suffix Products

| i | nums[i] | Calculation | suffix[i] | Meaning |
|:--|:--------|:------------|:----------|:--------|
| 3 | 4 | (no elements to right) | 1 | Empty product |
| 2 | 3 | nums[3] | 4 | Product of [4] |
| 1 | 2 | nums[2] Ã— nums[3] | 12 | Product of [3,4] |
| 0 | 1 | nums[1] Ã— nums[2] Ã— nums[3] | 24 | Product of [2,3,4] |

**Suffix Array**: `[24, 12, 4, 1]`

### Step 3: Combine

| i | prefix[i] | suffix[i] | result[i] | Verification |
|:--|:----------|:----------|:----------|:-------------|
| 0 | 1 | 24 | 24 | 2Ã—3Ã—4 = 24 âœ“ |
| 1 | 1 | 12 | 12 | 1Ã—3Ã—4 = 12 âœ“ |
| 2 | 2 | 4 | 8 | 1Ã—2Ã—4 = 8 âœ“ |
| 3 | 6 | 1 | 6 | 1Ã—2Ã—3 = 6 âœ“ |

**Final Answer**: `[24, 12, 8, 6]`

---

## Optimized Solution Trace

**Single array approach** (O(1) extra space):

| Pass | Direction | i | Operation | result array | Running product |
|:-----|:----------|:--|:----------|:-------------|:----------------|
| 1 | Leftâ†’Right | 0 | Store prefix | [1,_,_,_] | 1 |
| 1 | Leftâ†’Right | 1 | Store prefix | [1,1,_,_] | 1 |
| 1 | Leftâ†’Right | 2 | Store prefix | [1,1,2,_] | 2 |
| 1 | Leftâ†’Right | 3 | Store prefix | [1,1,2,6] | 6 |
| 2 | Rightâ†’Left | 3 | Multiply suffix | [1,1,2,6] | 1 |
| 2 | Rightâ†’Left | 2 | Multiply suffix | [1,1,8,6] | 4 |
| 2 | Rightâ†’Left | 1 | Multiply suffix | [1,12,8,6] | 12 |
| 2 | Rightâ†’Left | 0 | Multiply suffix | [24,12,8,6] | 24 |

---

## The Gym Metaphor Breakdown

| Coding Concept | Gym Equivalent |
|:---------------|:---------------|
| `nums` array | Team members' strength multipliers |
| `prefix[i]` | Combined strength of teammates to the LEFT |
| `suffix[i]` | Combined strength of teammates to the RIGHT |
| `result[i]` | Team strength when member i is resting |
| Forward pass | Walking left to right, accumulating strength |
| Backward pass | Walking right to left, accumulating strength |

---

## Why No Division?

The problem prohibits division because:

1. **Zero handling**: If any `nums[i] = 0`, division would cause errors
2. **Integer precision**: Division might cause floating-point issues
3. **Algorithm design**: Tests your understanding of prefix/suffix decomposition

---

# ğŸ“ˆ Complexity Analysis

## Three-Array Approach

### Time Complexity: O(n)

| Operation | Frequency | Cost | Total |
|:----------|:----------|:-----|:------|
| Build prefix | n iterations | O(1) | O(n) |
| Build suffix | n iterations | O(1) | O(n) |
| Build result | n iterations | O(1) | O(n) |

**Total**: O(n)

### Space Complexity: O(n)

| Storage | Size | Purpose |
|:--------|:-----|:--------|
| prefix array | n | Left products |
| suffix array | n | Right products |
| result array | n | Final answer (doesn't count) |

**Extra Space**: O(n)

---

## Optimized Approach

### Time Complexity: O(n)

Same as above â€” still three passes (can be done in two).

### Space Complexity: O(1) extra

| Storage | Size | Purpose |
|:--------|:-----|:--------|
| result array | n | Used for prefix, then final (doesn't count) |
| prefix variable | 1 | Running prefix product |
| suffix variable | 1 | Running suffix product |

**Extra Space**: O(1)

---

# ğŸ¯ Key Takeaways

## Pattern Recognition: Prefix/Suffix Decomposition

This problem teaches a fundamental technique:

> **Break down a problem into "what's before" and "what's after" each element.**

## When to Use This Pattern

| Problem Type | Example |
|:-------------|:--------|
| Excluding one element | Product/Sum except self |
| Range queries | Prefix sums |
| Stock problems | Best time to buy/sell |
| Trapping rain water | Height from left/right |

## Key Formula

$$\text{answer}[i] = \left(\prod_{j=0}^{i-1} \text{nums}[j]\right) \times \left(\prod_{j=i+1}^{n-1} \text{nums}[j]\right)$$

Or simply: `answer[i] = prefix[i] Ã— suffix[i]`

## Common Mistakes to Avoid

| Mistake | Why It's Wrong | Correct Approach |
|:--------|:---------------|:-----------------|
| Using division | Prohibited + zero issues | Use prefix/suffix |
| Off-by-one errors | Prefix/suffix boundaries | Carefully handle bounds |
| Including self | Product EXCEPT self | prefix excludes i, suffix excludes i |

---

# ğŸ† Practice Variations

Build on this concept with these related problems:

| Problem | Difficulty | Key Concept |
|:--------|:-----------|:------------|
| Running Sum of 1D Array | Easy | Prefix sum basics |
| Sum of All Odd Length Subarrays | Easy | Prefix sum application |
| Maximum Subarray | Medium | Kadane's (prefix-like) |
| Trapping Rain Water | Hard | Prefix/suffix maximums |
| Range Sum Query | Easy | Prefix sum for queries |

---

# ğŸ”§ Interview Discussion Points

## Why Not Use Division?

**Interviewer Concern**: What if we could use division?

```python
# If division was allowed:
def product_with_division(nums):
    total = 1
    zero_count = 0
    for n in nums:
        if n != 0:
            total *= n
        else:
            zero_count += 1
    
    result = []
    for n in nums:
        if zero_count > 1:
            result.append(0)
        elif zero_count == 1:
            result.append(0 if n != 0 else total)
        else:
            result.append(total // n)
    return result
```

**Issues**: Handling zeros is complex, integer division precision, etc.

## Edge Cases to Consider

| Case | Input | Output | Notes |
|:-----|:------|:-------|:------|
| Contains zero | `[1,2,0,4]` | `[0,0,8,0]` | Zero makes most products 0 |
| Multiple zeros | `[0,0,1]` | `[0,0,0]` | All products are 0 |
| Negative numbers | `[-1,2,-3]` | `[-6,-3,-2]` | Signs work correctly |
| Two elements | `[2,3]` | `[3,2]` | Minimum case |

---

*"In the gym of algorithms, prefix and suffix are like your left and right spotters â€” together they support any weight."* ğŸ’ªğŸ‹ï¸
