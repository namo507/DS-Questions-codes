---
title: "Merge Intervals"
subtitle: "LeetCode #56 | Medium | Arrays & Sorting"
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    code-block-bg: "#f5f5f5"
---

# üèãÔ∏è Problem Statement

**LeetCode #56 - Merge Intervals**

Given an array of `intervals` where `intervals[i] = [start·µ¢, end·µ¢]`, merge all overlapping intervals, and return an array of the **non-overlapping intervals** that cover all the intervals in the input.

## Examples

| Example | Input | Output |
|:--------|:------|:-------|
| 1 | `[[1,3],[2,6],[8,10],[15,18]]` | `[[1,6],[8,10],[15,18]]` |
| 2 | `[[1,4],[4,5]]` | `[[1,5]]` |

### Example 1 Visualization

```
Input:    [1,3] [2,6]    [8,10]    [15,18]
          |---|
            |----|
                        |---|
                                   |----|

Output:   [1,--------6]  [8,10]    [15,18]
          |--------|     |---|     |----|
```

## Constraints

- $1 \leq \text{intervals.length} \leq 10^4$
- `intervals[i].length == 2`
- $0 \leq \text{start}_i \leq \text{end}_i \leq 10^4$

## Companies That Ask This

| Company | Frequency |
|:--------|:----------|
| Google | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Meta | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê |

---

# üèãÔ∏è The Gym Metaphor: Merging Class Schedules

## Understanding the Problem Through Fitness

Imagine you're the **gym scheduler** consolidating overlapping fitness classes:

```
Original Schedule:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 6am    7am    8am    9am   10am   11am   12pm     ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                                          ‚îÇ Yoga (6-7)
‚îÇ        ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                               ‚îÇ Pilates (7-9)
‚îÇ                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                        ‚îÇ HIIT (9-10)
‚îÇ                          ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§             ‚îÇ Spin (10-12)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**The Problem**: Some classes overlap (same instructor needed)!

**Your Task**: Merge overlapping time slots so instructors know their actual busy periods.

---

## When Do Classes Overlap?

Two time slots `[a, b]` and `[c, d]` overlap if:

```
Case 1: Partial overlap    Case 2: One contains other    Case 3: Adjacent
[a‚îÄ‚îÄ‚îÄ‚îÄb]                   [a‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄb]                  [a‚îÄ‚îÄ‚îÄ‚îÄb]
   [c‚îÄ‚îÄ‚îÄ‚îÄd]                   [c‚îÄ‚îÄd]                           [c‚îÄ‚îÄ‚îÄ‚îÄd]
   
Result: [a‚îÄ‚îÄ‚îÄ‚îÄd]           Result: [a‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄb]          Result: [a‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄd]
```

**Key Insight**: If sorted by start time, two consecutive intervals overlap when:

$$\text{current.start} \leq \text{previous.end}$$

---

## The Algorithm: Sort, Then Merge

### Step 1: Sort by Start Time

```
Before: [1,3], [8,10], [2,6], [15,18]
After:  [1,3], [2,6], [8,10], [15,18]
        ‚Üë sorted by first element
```

### Step 2: Iterate and Merge

```
Start with first interval: [1,3]

Check [2,6]: 2 ‚â§ 3? YES ‚Üí Merge to [1,6]
Check [8,10]: 8 ‚â§ 6? NO ‚Üí Add [8,10] as new interval
Check [15,18]: 15 ‚â§ 10? NO ‚Üí Add [15,18] as new interval

Result: [[1,6], [8,10], [15,18]]
```

### Visual Walkthrough

| Step | Current Interval | Next | Overlap? | Action | Merged List |
|:-----|:-----------------|:-----|:---------|:-------|:------------|
| 1 | ‚Äî | [1,3] | ‚Äî | Start with [1,3] | [[1,3]] |
| 2 | [1,3] | [2,6] | 2 ‚â§ 3 ‚úì | Merge to [1,6] | [[1,6]] |
| 3 | [1,6] | [8,10] | 8 ‚â§ 6 ‚úó | Add new | [[1,6],[8,10]] |
| 4 | [8,10] | [15,18] | 15 ‚â§ 10 ‚úó | Add new | [[1,6],[8,10],[15,18]] |

---

# üíª Python Solution

```{python}
def merge(intervals: list[list[int]]) -> list[list[int]]:
    """
    Merge overlapping intervals.
    
    The Class Schedule Merger Strategy:
    1. Sort classes by start time
    2. Walk through schedule, merging overlapping slots
    3. Two slots overlap if current.start ‚â§ previous.end
    
    Time Complexity: O(n log n) - Sorting dominates
    Space Complexity: O(n) - Result storage
    """
    if not intervals:
        return []
    
    # Sort by start time (get classes in order)
    intervals.sort(key=lambda x: x[0])
    
    # Start with the first interval
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        # Get the last interval in our merged list
        last = merged[-1]
        
        # Check for overlap: current starts before/when last ends
        if current[0] <= last[1]:
            # Merge by extending the end time
            last[1] = max(last[1], current[1])
        else:
            # No overlap, add as new interval
            merged.append(current)
    
    return merged


# Test cases
print("Example 1:", merge([[1,3],[2,6],[8,10],[15,18]]))  # [[1,6],[8,10],[15,18]]
print("Example 2:", merge([[1,4],[4,5]]))                 # [[1,5]]
print("Example 3:", merge([[1,4],[0,4]]))                 # [[0,4]]


# Alternative: More explicit version
def merge_verbose(intervals: list[list[int]]) -> list[list[int]]:
    """
    Verbose version with detailed tracking.
    """
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = []
    current_start = intervals[0][0]
    current_end = intervals[0][1]
    
    for i in range(1, len(intervals)):
        next_start, next_end = intervals[i]
        
        if next_start <= current_end:
            # Overlap! Extend current interval
            current_end = max(current_end, next_end)
            print(f"Merged: [{current_start}, {current_end}]")
        else:
            # No overlap, save current and start new
            merged.append([current_start, current_end])
            current_start = next_start
            current_end = next_end
            print(f"New interval: [{current_start}, {current_end}]")
    
    # Don't forget the last interval!
    merged.append([current_start, current_end])
    
    return merged


print("\nVerbose version:")
merge_verbose([[1,3],[2,6],[8,10],[15,18]])
```

---

# üìä R Solution

```{r}
merge_intervals <- function(intervals) {
  #' Merge overlapping intervals.
  #' 
  #' The Class Schedule Merger Strategy:
  #' 1. Sort classes by start time
  #' 2. Walk through schedule, merging overlapping slots
  #' 3. Two slots overlap if current.start ‚â§ previous.end
  #' 
  #' Time Complexity: O(n log n)
  #' Space Complexity: O(n)
  
  if (length(intervals) == 0) {
    return(list())
  }
  
  # Convert to matrix if list of vectors
  if (is.list(intervals)) {
    intervals <- do.call(rbind, intervals)
  }
  
  # Sort by start time
  intervals <- intervals[order(intervals[, 1]), , drop = FALSE]
  
  # Initialize merged list with first interval
  merged <- list()
  current <- intervals[1, ]
  
  if (nrow(intervals) > 1) {
    for (i in 2:nrow(intervals)) {
      next_interval <- intervals[i, ]
      
      # Check for overlap
      if (next_interval[1] <= current[2]) {
        # Merge by extending end
        current[2] <- max(current[2], next_interval[2])
      } else {
        # No overlap, save current and start new
        merged <- append(merged, list(current))
        current <- next_interval
      }
    }
  }
  
  # Add the last interval
  merged <- append(merged, list(current))
  
  # Convert back to matrix format
  result <- do.call(rbind, merged)
  return(result)
}


# Test cases
cat("Example 1:\n")
result1 <- merge_intervals(list(c(1,3), c(2,6), c(8,10), c(15,18)))
print(result1)

cat("\nExample 2:\n")
result2 <- merge_intervals(list(c(1,4), c(4,5)))
print(result2)

cat("\nExample 3:\n")
result3 <- merge_intervals(list(c(1,4), c(0,4)))
print(result3)


# Data frame approach (more R-idiomatic)
merge_intervals_df <- function(intervals_df) {
  #' Using data frame for clearer R-style code
  
  library(dplyr)
  
  # Sort by start
  df <- intervals_df %>%
    arrange(start) %>%
    mutate(group = NA_integer_)
  
  # Assign groups for merging
  group <- 1
  current_end <- df$start[1] - 1  # Initialize to impossible value
  
  for (i in 1:nrow(df)) {
    if (df$start[i] <= current_end) {
      # Overlaps with current group
      df$group[i] <- group
      current_end <- max(current_end, df$end[i])
    } else {
      # New group
      group <- group + 1
      df$group[i] <- group
      current_end <- df$end[i]
    }
  }
  
  # Merge within groups
  result <- df %>%
    group_by(group) %>%
    summarise(start = min(start), end = max(end)) %>%
    select(start, end)
  
  return(result)
}


# Test with data frame
library(dplyr)
intervals_df <- data.frame(start = c(1, 2, 8, 15), end = c(3, 6, 10, 18))
cat("\nData frame approach:\n")
print(merge_intervals_df(intervals_df))
```

---

# üîç Solution Breakdown: The Full Gym Session Analysis

## Step-by-Step Trace

**Input**: `[[1,3], [8,10], [2,6], [15,18]]`

### Step 1: Sort by Start Time

| Original Order | Sorted Order |
|:---------------|:-------------|
| [1,3] | [1,3] |
| [8,10] | [2,6] |
| [2,6] | [8,10] |
| [15,18] | [15,18] |

### Step 2: Merge Process

| Iteration | Current Last | Next Interval | Condition | Action | Merged List |
|:----------|:-------------|:--------------|:----------|:-------|:------------|
| Init | ‚Äî | [1,3] | ‚Äî | Add first | [[1,3]] |
| 1 | [1,3] | [2,6] | 2 ‚â§ 3? ‚úì | Merge: [1, max(3,6)] | [[1,6]] |
| 2 | [1,6] | [8,10] | 8 ‚â§ 6? ‚úó | Add new | [[1,6], [8,10]] |
| 3 | [8,10] | [15,18] | 15 ‚â§ 10? ‚úó | Add new | [[1,6], [8,10], [15,18]] |

**Output**: `[[1,6], [8,10], [15,18]]`

---

## Edge Cases Analysis

### Case 1: Adjacent Intervals (touch at endpoint)

```
Input: [[1,4], [4,5]]
After sort: [[1,4], [4,5]]

Check: 4 ‚â§ 4? YES ‚Üí Merge to [1,5]
Output: [[1,5]]
```

### Case 2: One Interval Contains Another

```
Input: [[1,4], [2,3]]
After sort: [[1,4], [2,3]]

Check: 2 ‚â§ 4? YES ‚Üí Merge to [1, max(4,3)] = [1,4]
Output: [[1,4]]
```

### Case 3: No Overlaps

```
Input: [[1,2], [4,5], [7,8]]
After sort: [[1,2], [4,5], [7,8]]

Check 4 ‚â§ 2? NO ‚Üí Keep separate
Check 7 ‚â§ 5? NO ‚Üí Keep separate
Output: [[1,2], [4,5], [7,8]]
```

---

## The Gym Metaphor Breakdown

| Coding Concept | Gym Equivalent |
|:---------------|:---------------|
| Interval [start, end] | Class time slot |
| Sorting by start | Organizing schedule chronologically |
| Overlapping intervals | Back-to-back or conflicting classes |
| Merging | Combining instructor busy periods |
| Non-overlapping result | Clean schedule with gaps |

---

# üìà Complexity Analysis

## Time Complexity: O(n log n)

| Operation | Complexity | Notes |
|:----------|:-----------|:------|
| Sorting | O(n log n) | Dominant operation |
| Single pass merge | O(n) | Visit each interval once |
| **Total** | **O(n log n)** | Sorting dominates |

## Space Complexity: O(n)

| Component | Space | Notes |
|:----------|:------|:------|
| Sorting | O(log n) to O(n) | Depends on algorithm |
| Result array | O(n) | Worst case: no merges |
| **Total** | **O(n)** | Result storage |

---

# üéØ Key Takeaways

## Pattern Recognition: Interval Problems

This problem teaches the classic interval pattern:

> **Sort intervals by start time, then process sequentially to handle overlaps.**

## The Merge Condition

Two intervals `[a,b]` and `[c,d]` (sorted, so `a ‚â§ c`) merge when:

$$c \leq b$$

Result: `[a, max(b, d)]`

## Common Interval Problem Types

| Type | Description | Example |
|:-----|:------------|:--------|
| Merge | Combine overlapping | This problem |
| Insert | Add and merge | Insert Interval |
| Count overlaps | Meeting rooms | Meeting Rooms II |
| Find gaps | Non-overlapping ranges | Employee Free Time |

---

# üèÜ Practice Variations

Build on this concept:

| Problem | Difficulty | Key Extension |
|:--------|:-----------|:--------------|
| Insert Interval | Medium | Insert then merge |
| Meeting Rooms | Easy | Check any overlap |
| Meeting Rooms II | Medium | Count max overlaps |
| Non-overlapping Intervals | Medium | Remove minimum to avoid overlap |
| Employee Free Time | Hard | Find gaps across schedules |

---

# üîß Interview Discussion Points

## Why Sort First?

Without sorting:
- Must compare every pair ‚Üí O(n¬≤)
- Complex merge logic

With sorting:
- Only compare adjacent ‚Üí O(n) after sort
- Simple merge rule

## Alternative: Interval Tree

For **dynamic** interval operations (frequent inserts):
- Use an interval tree or segment tree
- O(log n) per operation instead of re-sorting

## Follow-up: What If Intervals Are Streaming?

Use a **priority queue (min-heap)** to maintain sorted order:

```python
import heapq

def merge_streaming(stream):
    """Handle intervals arriving one at a time."""
    heap = []
    for interval in stream:
        heapq.heappush(heap, interval)
    
    result = []
    while heap:
        current = heapq.heappop(heap)
        if result and current[0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], current[1])
        else:
            result.append(current)
    return result
```

---

*"In the gym of algorithms, sorting is like warming up ‚Äî it makes everything else easier."* üí™üìÖ
