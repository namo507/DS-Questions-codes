---
title: "Coin Change"
subtitle: "LeetCode #322 | Medium | Dynamic Programming"
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    code-block-bg: "#f5f5f5"
---

# üèãÔ∏è Problem Statement

**LeetCode #322 - Coin Change**

You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

Return the **fewest number of coins** that you need to make up that amount. If that amount cannot be made up by any combination of the coins, return `-1`.

You may assume that you have an infinite number of each kind of coin.

## Examples

| Example | Coins | Amount | Output | Explanation |
|:--------|:------|:-------|:-------|:------------|
| 1 | [1,2,5] | 11 | 3 | 5 + 5 + 1 = 11 |
| 2 | [2] | 3 | -1 | Can't make 3 with only 2s |
| 3 | [1] | 0 | 0 | No coins needed |

## Constraints

- $1 \leq \text{coins.length} \leq 12$
- $1 \leq \text{coins[i]} \leq 2^{31} - 1$
- $0 \leq \text{amount} \leq 10^4$

## Companies That Ask This

| Company | Frequency |
|:--------|:----------|
| Amazon | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| Microsoft | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Bloomberg | ‚≠ê‚≠ê‚≠ê‚≠ê |
| Apple | ‚≠ê‚≠ê‚≠ê |
| Goldman Sachs | ‚≠ê‚≠ê‚≠ê |

---

# üèãÔ∏è The Gym Metaphor: The Protein Shake Mixer

## Understanding the Problem Through Fitness

Imagine you're at the **gym smoothie bar** trying to make a **target protein amount** with the fewest scoops:

```
Available Protein Scoops:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  ü•Ñ 5g scoop   ü•Ñ 2g scoop   ü•Ñ 1g scoop‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  Target: 11g of protein                 ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  Goal: Use MINIMUM number of scoops!    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Solution:
  5g + 5g + 1g = 11g  ‚Üê Only 3 scoops! ‚úì
  
NOT:
  2g √ó 5 + 1g = 11g   ‚Üê 6 scoops (too many)
```

---

## The Greedy Trap ‚ö†Ô∏è

**Greedy doesn't always work!**

```
Coins: [1, 3, 4]
Amount: 6

Greedy approach (always pick largest):
  4 + 1 + 1 = 6  ‚Üê 3 coins

Optimal approach:
  3 + 3 = 6      ‚Üê 2 coins! ‚úì

Greedy fails because it can't "undo" choices!
```

---

## Dynamic Programming: Building Up Solutions

Think of it as tracking the **minimum scoops for every possible amount**:

```
Amount:    0   1   2   3   4   5   6   7   8   9  10  11
Min coins: 0   1   1   2   2   1   2   2   3   3   2   3

For amount 11 with coins [1, 2, 5]:
- Use 1: dp[11] = dp[10] + 1 = 2 + 1 = 3
- Use 2: dp[11] = dp[9] + 1 = 3 + 1 = 4  
- Use 5: dp[11] = dp[6] + 1 = 2 + 1 = 3

Minimum = 3
```

---

## The Recurrence Relation

$$dp[i] = \min(dp[i - coin] + 1) \text{ for all valid coins}$$

Where:
- $dp[i]$ = minimum coins to make amount $i$
- We try each coin and take the minimum

---

# üíª Python Solutions

## Bottom-Up DP (Tabulation)

```{python}
def coinChange(coins: list[int], amount: int) -> int:
    """
    Bottom-up dynamic programming solution.
    
    The "Protein Tracking Board" Strategy:
    1. Create a board tracking min scoops for each amount
    2. For each amount from 1 to target:
       - Try each scoop size
       - Take the minimum scoops needed
    3. Build up from 0 to target amount
    
    Time: O(amount √ó len(coins))
    Space: O(amount)
    """
    # Initialize dp array with "impossible" value
    # amount + 1 is impossible since we'd need at least 'amount' coins of value 1
    dp = [amount + 1] * (amount + 1)
    
    # Base case: 0 coins needed to make amount 0
    dp[0] = 0
    
    # Build up solutions for each amount
    for current_amount in range(1, amount + 1):
        for coin in coins:
            if coin <= current_amount:
                # Can use this coin; check if it gives fewer coins
                dp[current_amount] = min(
                    dp[current_amount],
                    dp[current_amount - coin] + 1
                )
    
    # If dp[amount] wasn't updated, return -1 (impossible)
    return dp[amount] if dp[amount] != amount + 1 else -1


# Test cases
print("Example 1:", coinChange([1, 2, 5], 11))   # 3
print("Example 2:", coinChange([2], 3))          # -1
print("Example 3:", coinChange([1], 0))          # 0
print("Example 4:", coinChange([1, 3, 4], 6))    # 2 (3+3)
```

## Verbose Version with Trace

```{python}
def coinChange_verbose(coins: list[int], amount: int) -> int:
    """Verbose version showing the DP table building."""
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0
    
    print(f"Coins: {coins}, Amount: {amount}")
    print("=" * 60)
    print(f"Initial dp: {dp[:min(15, amount+1)]}...")
    
    for current in range(1, amount + 1):
        for coin in coins:
            if coin <= current and dp[current - coin] + 1 < dp[current]:
                old = dp[current]
                dp[current] = dp[current - coin] + 1
                if current <= 12:  # Only show for small amounts
                    print(f"dp[{current}]: {old} ‚Üí {dp[current]} (using coin {coin})")
    
    print(f"\nFinal dp: {dp[:min(15, amount+1)]}...")
    result = dp[amount] if dp[amount] != amount + 1 else -1
    print(f"Answer: {result}")
    return result


coinChange_verbose([1, 2, 5], 11)
```

## Top-Down DP (Memoization)

```{python}
def coinChange_memo(coins: list[int], amount: int) -> int:
    """
    Top-down recursive solution with memoization.
    
    The "Smart Trainer" Strategy:
    - Ask: "What's the minimum coins for this amount?"
    - If we've calculated before, return cached answer
    - Otherwise, try each coin and remember the best
    
    Time: O(amount √ó len(coins))
    Space: O(amount) for memo + O(amount) for recursion
    """
    memo = {}
    
    def dp(remaining):
        # Base cases
        if remaining == 0:
            return 0
        if remaining < 0:
            return float('inf')
        
        # Check cache
        if remaining in memo:
            return memo[remaining]
        
        # Try each coin, take minimum
        min_coins = float('inf')
        for coin in coins:
            result = dp(remaining - coin)
            min_coins = min(min_coins, result + 1)
        
        # Cache and return
        memo[remaining] = min_coins
        return min_coins
    
    result = dp(amount)
    return result if result != float('inf') else -1


print("\nMemoization approach:")
print("Example 1:", coinChange_memo([1, 2, 5], 11))   # 3
print("Example 2:", coinChange_memo([2], 3))          # -1
```

## BFS Approach (Alternative)

```{python}
from collections import deque

def coinChange_bfs(coins: list[int], amount: int) -> int:
    """
    BFS approach - find shortest path to target amount.
    
    Think of it as: each amount is a node, each coin is an edge.
    Find shortest path from 'amount' to 0.
    
    Time: O(amount √ó len(coins))
    Space: O(amount)
    """
    if amount == 0:
        return 0
    
    visited = set([amount])
    queue = deque([(amount, 0)])  # (remaining, coins_used)
    
    while queue:
        remaining, coins_used = queue.popleft()
        
        for coin in coins:
            new_remaining = remaining - coin
            
            if new_remaining == 0:
                return coins_used + 1
            
            if new_remaining > 0 and new_remaining not in visited:
                visited.add(new_remaining)
                queue.append((new_remaining, coins_used + 1))
    
    return -1


print("\nBFS approach:")
print("Example 1:", coinChange_bfs([1, 2, 5], 11))   # 3
```

---

# üìä R Solutions

```{r}
# Bottom-Up DP
coin_change <- function(coins, amount) {
  #' Bottom-up dynamic programming solution.
  #' 
  #' Time: O(amount √ó len(coins))
  #' Space: O(amount)
  
  # Initialize with impossible value
  dp <- rep(amount + 1, amount + 1)
  dp[1] <- 0  # dp[1] corresponds to amount 0 in 1-indexed R
  
  for (current in 1:amount) {
    for (coin in coins) {
      if (coin <= current) {
        # R is 1-indexed, so dp[current+1] is for amount 'current'
        prev_idx <- current - coin + 1
        dp[current + 1] <- min(dp[current + 1], dp[prev_idx] + 1)
      }
    }
  }
  
  result <- dp[amount + 1]
  if (result > amount) {
    return(-1)
  }
  return(result)
}


cat("Bottom-Up DP:\n")
print(coin_change(c(1, 2, 5), 11))  # 3
print(coin_change(c(2), 3))         # -1
print(coin_change(c(1), 0))         # 0
print(coin_change(c(1, 3, 4), 6))   # 2


# With detailed output
coin_change_verbose <- function(coins, amount) {
  #' Verbose version showing the table
  
  if (amount == 0) return(0)
  
  dp <- rep(amount + 1, amount + 1)
  dp[1] <- 0
  
  for (current in 1:amount) {
    for (coin in coins) {
      if (coin <= current) {
        prev_idx <- current - coin + 1
        if (dp[prev_idx] + 1 < dp[current + 1]) {
          dp[current + 1] <- dp[prev_idx] + 1
        }
      }
    }
  }
  
  cat("Amount:", 0:(amount), "\n")
  cat("Coins: ", dp[1:(amount+1)], "\n")
  
  result <- dp[amount + 1]
  return(ifelse(result > amount, -1, result))
}


cat("\nVerbose output:\n")
coin_change_verbose(c(1, 2, 5), 11)


# Memoized recursive version
coin_change_memo <- function(coins, amount) {
  #' Top-down memoization approach
  
  memo <- new.env(hash = TRUE)
  
  dp <- function(remaining) {
    if (remaining == 0) return(0)
    if (remaining < 0) return(Inf)
    
    key <- as.character(remaining)
    if (exists(key, envir = memo)) {
      return(get(key, envir = memo))
    }
    
    min_coins <- Inf
    for (coin in coins) {
      result <- dp(remaining - coin)
      min_coins <- min(min_coins, result + 1)
    }
    
    assign(key, min_coins, envir = memo)
    return(min_coins)
  }
  
  result <- dp(amount)
  return(ifelse(is.infinite(result), -1, result))
}


cat("\nMemoization approach:\n")
print(coin_change_memo(c(1, 2, 5), 11))  # 3
print(coin_change_memo(c(2), 3))          # -1
```

---

# üîç Solution Breakdown: Full Gym Analysis

## Step-by-Step DP Table

**Input**: `coins = [1, 2, 5], amount = 11`

### Building the Table

| Amount | Try coin 1 | Try coin 2 | Try coin 5 | Min |
|:-------|:-----------|:-----------|:-----------|:----|
| 0 | ‚Äî | ‚Äî | ‚Äî | 0 (base) |
| 1 | dp[0]+1=1 | ‚Äî | ‚Äî | 1 |
| 2 | dp[1]+1=2 | dp[0]+1=1 | ‚Äî | 1 |
| 3 | dp[2]+1=2 | dp[1]+1=2 | ‚Äî | 2 |
| 4 | dp[3]+1=3 | dp[2]+1=2 | ‚Äî | 2 |
| 5 | dp[4]+1=3 | dp[3]+1=3 | dp[0]+1=1 | 1 |
| 6 | dp[5]+1=2 | dp[4]+1=3 | dp[1]+1=2 | 2 |
| 7 | dp[6]+1=3 | dp[5]+1=2 | dp[2]+1=2 | 2 |
| 8 | dp[7]+1=3 | dp[6]+1=3 | dp[3]+1=3 | 3 |
| 9 | dp[8]+1=4 | dp[7]+1=3 | dp[4]+1=3 | 3 |
| 10 | dp[9]+1=4 | dp[8]+1=4 | dp[5]+1=2 | 2 |
| 11 | dp[10]+1=3 | dp[9]+1=4 | dp[6]+1=3 | 3 |

**Answer**: dp[11] = 3

### Reconstructing the Solution

```
dp[11] = 3, came from dp[10] + coin 1 = 2 + 1
dp[10] = 2, came from dp[5] + coin 5 = 1 + 1
dp[5] = 1, came from dp[0] + coin 5 = 0 + 1

Solution: 5 + 5 + 1 = 11 (3 coins)
```

---

## Visual DP Process

```
Building minimum coins table:

Amount: 0  1  2  3  4  5  6  7  8  9  10  11
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Coins:  ‚îÇ 0  1  1  2  2  1  2  2  3  3  2  3‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚Üë
                      Answer: 3

For amount 11:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Option 1: Use coin 1 ‚Üí dp[10] + 1 = 3   ‚îÇ
‚îÇ Option 2: Use coin 2 ‚Üí dp[9] + 1 = 4    ‚îÇ
‚îÇ Option 3: Use coin 5 ‚Üí dp[6] + 1 = 3    ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ Minimum: 3                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

# üìà Complexity Analysis

## Time Complexity: O(amount √ó n)

| Operation | Count |
|:----------|:------|
| Outer loop (amounts) | O(amount) |
| Inner loop (coins) | O(n) |
| **Total** | **O(amount √ó n)** |

## Space Complexity: O(amount)

| Component | Space |
|:----------|:------|
| DP array | O(amount) |
| **Total** | **O(amount)** |

---

# üéØ Key Takeaways

## The Unbounded Knapsack Pattern

Coin Change is a classic example of **unbounded knapsack**:

- Each item (coin) can be used **unlimited times**
- We want to **minimize** the count (or maximize value)
- We iterate through amounts, not items

```python
# Unbounded knapsack template
for amount in range(1, target + 1):
    for item in items:
        if item <= amount:
            dp[amount] = optimal(dp[amount], dp[amount - item] + 1)
```

## Why Greedy Fails

```
Greedy: Always pick largest coin possible
Problem: Can't "undo" bad choices

Counter-example: coins = [1, 3, 4], amount = 6
Greedy: 4 + 1 + 1 = 3 coins
Optimal: 3 + 3 = 2 coins

DP explores ALL possibilities!
```

## Initialization Matters

```python
# Use amount + 1 (impossible value) not infinity
dp = [amount + 1] * (amount + 1)

# This helps detect impossible cases
if dp[amount] == amount + 1:
    return -1  # Can't make this amount
```

---

# üîß Interview Tips

## Common Mistakes

| Mistake | Solution |
|:--------|:---------|
| Using greedy | Remember counter-example |
| Wrong initialization | Use amount+1 not infinity |
| Off-by-one errors | dp[0] = 0 is base case |
| Not checking impossible | Check if dp[amount] unchanged |

## Follow-up Questions

**Q: Print the actual coins used?**
A: Track which coin led to minimum at each step

```python
def coinChange_with_coins(coins, amount):
    dp = [amount + 1] * (amount + 1)
    parent = [-1] * (amount + 1)  # Track which coin
    dp[0] = 0
    
    for a in range(1, amount + 1):
        for coin in coins:
            if coin <= a and dp[a - coin] + 1 < dp[a]:
                dp[a] = dp[a - coin] + 1
                parent[a] = coin
    
    # Reconstruct
    result = []
    while amount > 0:
        result.append(parent[amount])
        amount -= parent[amount]
    return result


print(coinChange_with_coins([1, 2, 5], 11))  # [1, 5, 5]
```

**Q: Count number of ways to make amount?**
A: Change min to sum (combination sum problem)

---

# üèÜ Related Problems

| Problem | Difficulty | Key Difference |
|:--------|:-----------|:---------------|
| Coin Change 2 | Medium | Count ways, not min |
| Perfect Squares | Medium | Squares as "coins" |
| Combination Sum IV | Medium | Order matters |
| Minimum Cost For Tickets | Medium | Variable "coin" values |

---

# üí° The Gym Metaphor Summary

| Coding Concept | Gym Equivalent |
|:---------------|:---------------|
| Coins array | Available scoop sizes |
| Amount | Target protein grams |
| DP array | Tracking board |
| dp[i] | Min scoops for i grams |
| Recurrence | "If I use this scoop..." |
| Optimal substructure | Smaller amounts solved first |

---

*"In the gym of dynamic programming, coin change teaches you that sometimes the biggest scoop isn't the best choice ‚Äî you need to explore all combinations to find the optimal mix!"* üí™ü•§
